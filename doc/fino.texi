\input texinfo @c -*-texinfo-*-
@c %**start of header
@documentencoding UTF-8

@setfilename fino.info
@set UPDATED February 20, 2020
@set VERSION v0.7

@copying
This manual is for fino (version @value{VERSION}, @value{UPDATED}),
which is a completely free-as-in-freedom finite-element
thermo-mechancial solver desinged and implemented following the UNIX
principles.

Copyright @copyright{} 2016-2020 Jeremy Theler.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Fino
@subtitle a free finite-element thermo-mechanical solver, v0.7
@author Jeremy Theler
February 20, 2020
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@node Top
@top Fino

@menu
* Overview::
* Running blackjack::
* Reference::
@end menu

@node Overview
@chapter Overview
@anchor{#overview}
Fino is a free and open source tool released under the terms of the
GPLv3+ that uses the finite-element method to solve

@itemize
@item
steady-state thermo-mechanical problems, or
@item
steady or transient heat conduction problems, or
@item
modal analysis problems.
@end itemize

@float
@image{fino-logo,,,Updates, examples, V&V cases and full reference:
@url{https://www.seamplex.com/fino},}
@caption{Updates, examples, V&V cases and full reference:
@url{https://www.seamplex.com/fino}}
@end float

@node Running blackjack
@chapter Running @code{blackjack}
@anchor{#running-blackjack}

@menu
* Invocation::
@end menu

@node Invocation
@section Invocation
@anchor{#invocation}
The format for running the @code{fino} program is:

@verbatim
fino [options] inputfile [optional_extra_arguments]...
@end verbatim

The @code{fino} executable supports the following options:

@table @asis
@item @code{-d} or @code{--debug}

Start in debug mode

@item @code{--node-debug}

Ignore standard input, avoid debug mode

@item @code{-l} or @code{--list}

List defined symbols and exit

@item @code{-h} or @code{--help}

Display this help and exit

@item @code{-i} or @code{--info}

Display detailed code information and exit

@item @code{-v} or @code{--version}

Display version information and exit

@item @code{--mumps}

use the MUMPS direct solver (if available)

@item @code{--petsc <option[=argument]>}

Pass @code{-option argument} directly to PETSc/SLEPc, e.g.

@verbatim
$ fino tensile-test.fin --petsc ksp_view
@end verbatim

The option @code{--petsc} is provided to avoid clashes with PETSc'
non-POSIX arguments. Note that options are passed directly to
PETSc/SLEPc if they do not clash with Fino/wasora. The same command as
above could have been called as

@verbatim
$ fino tensile-test.fin -ksp_view
@end verbatim

@end table

Input file instructions are read from standard input if @code{-} is
passed as inputfile.

@node Reference
@chapter Reference
@anchor{#reference}

@menu
* Fino keywords::
* Mesh keywords::
* Special input distributions::
* Boundary conditions::
* Boundary conditions::
* Result functions::
* Wasora keywords::
* Fino variables::
@end menu

@node Fino keywords
@section Fino keywords
@anchor{#fino-keywords}

@menu
* FINO_LINEARIZE::
* FINO_PROBLEM::
* FINO_REACTION::
* FINO_SOLVER::
* FINO_STEP::
@end menu

@node FINO_LINEARIZE
@subsection FINO_LINEARIZE
@anchor{#fino_linearize}
@quotation
Performs stress linearization according to ASME VII-Sec 5 over a Stress
Classification Line
@end quotation

@verbatim
FINO_LINEARIZE { PHYSICAL_GROUP <physical_group> | START_POINT <x1> <y1> <z1> END_POINT <x2> <y2> <z2> }
 [ FILE <file_id> | FILE_PATH <file_path> ]
 [ TOTAL { vonmises tresca | tresca | principal1 | principal2 | principal3 }
 [ M <variable> ]
 [ MB <variable> ]
 [ PEAK <variable> ]
@end verbatim

The Stress Classification Line (SCL) may be given either as a
one-dimensional physical entity in the mesh or as the (continuous)
spatial coordinates of two end-points. If the SCL is given as a
@code{PHYSICAL_GROUP}, the entity should be one-dimensional (i.e a line)
independently of the dimension of the problem. If the SCL is given with
@code{START_POINT} and @code{END_POINT}, the number of coordinates given
should match the problem dimension (i.e three coordinates for full@ 3D
problems and two coordinates for axisymmetric or plane problems).
Coordinates can be given algebraic expressions that will be evaluated at
the time of the linearization. If either a @code{FILE} or a
@code{FILE_PATH} is given, the total, membrane and membrane plus bending
stresses are written as a function of a scalar @math{t \in [0,1]}.
Moreover, the individual elements of the membrane and bending stress
tensors are written within comments (i.e.@ lines starting with the hash
symbol @code{#}). By default, the linearization uses the Von@ Mises
criterion for the composition of stresses. The definition of what
@emph{total stress} means can be changed using the @code{TOTAL} keyword.
The membrane, bending and peak stress tensor elements are combined using
the Von@ Mises criterion and stored as variables. If no name for any of
the variables is given, they are stored in @code{M_entity},
@code{B_entity} and @code{P_entity} respectively if there is a physical
entity. Otherwise @code{M_1}, @code{B_1} and @code{P_1} for the first
instruction, @code{M_2}@dots{} etc.

@node FINO_PROBLEM
@subsection FINO_PROBLEM
@anchor{#fino_problem}
@quotation
Sets the problem type that Fino has to solve.
@end quotation

@verbatim
FINO_PROBLEM [ mechanical | thermal | modal ]
 [ AXISYMMETRIC | PLANE_STRESS | PLANE_STRAIN ] [ SYMMETRY_AXIS { x | y } ] [ LINEAR | NON_LINEAR ]
 [ DIMENSIONS <expr> ] [ MESH <identifier> ] 
 [ N_MODES <expr> ] 
@end verbatim

@itemize
@item
@code{mechanical} (or @code{elastic} or @code{break}, default) solves
the mechanical elastic problem (default).
@item
@code{thermal} (or @code{heat} or @code{bake}) solves the heat
conduction problem.
@item
@code{modal} (or @code{shake}) computes the natural frequencies and
oscillation modes.
@end itemize

If the @code{AXISYMMETRIC} keyword is given, the mesh is expected to be
two-dimensional in the @math{x}-@math{y} plane and the problem is
assumed to be axi-symmetric around the axis given by
@code{SYMMETRY_AXIS} (default is @math{y}). If the problem type is
mechanical and the mesh is two-dimensional on the @math{x}-@math{y}
plane and no axisymmetry is given, either @code{PLANE_STRESS} and
@code{PLAIN_STRAIN} can be provided (default is plane stress). By
default Fino tries to detect wheter the computation should be linear or
non-linear. An explicit mode can be set with either @code{LINEAR} on
@code{NON_LINEAR}. The number of spatial dimensions of the problem needs
to be given either with the keyword @code{DIMENSIONS} or by defining a
@code{MESH} (with an explicit @code{DIMENSIONS} keyword) before
@code{FINO_PROBLEM}. If there are more than one @code{MESH}es define,
the one over which the problem is to be solved can be defined by giving
the explicit mesh name with @code{MESH}. By default, the first mesh to
be defined in the input file is the one over which the problem is
solved. The number of modes to be computed in the modal problem. The
default is DEFAULT_NMODES.

@node FINO_REACTION
@subsection FINO_REACTION
@anchor{#fino_reaction}
@quotation
Computes the reaction at the selected physical entity.
@end quotation

@verbatim
FINO_REACTION PHYSICAL_GROUP <physical_group> [ RESULT { <variable> | <vector> } ]
@end verbatim

The result is stored in the variable or vector provided, depending on
the number of degrees of freedoms of the problem. If the object passed
as @code{RESULT} does not exist, an appropriate object (scalar variable
or vector) is created. For the elastic problem, the components of the
total reaction force are stored in the result vector. For the thermal
problem, the total power passing through the entity is computed as an
scalar.

@node FINO_SOLVER
@subsection FINO_SOLVER
@anchor{#fino_solver}
@quotation
Sets options related to the solver and the computation of gradients.
@end quotation

@verbatim
FINO_SOLVER [ PROGRESS_ASCII ]
 [ PC_TYPE { gamg | mumps | lu | hypre | sor | bjacobi | cholesky | ... } ]
 [ KSP_TYPE { gmres | mumps | bcgs | bicg | richardson | chebyshev | ... } ]
 [ SNES_TYPE { newtonls | newtontr | nrichardson | ngmres | qn | ngs | ... } ]
 [ GRADIENT { gauss | nodes | none } ]
 [ GRADIENT_HIGHER { average | nodes } ]
 [ SMOOTH { always | never | material } ]
 [ ELEMENT_WEIGHT { volume_times_quality volume | quality | flat } ]
@end verbatim

If the keyword @code{PROGRESS_ASCII} is given, three ASCII lines will
show in the terminal the progress of the ensamble of the stiffness
matrix (or matrices), the solution of the system of equations and the
computation of gradients (stresses). The preconditioner, linear and
non-linear solver might be any of those available in PETSc:

@itemize
@item
List of @code{PC_TYPE}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCType.html}.
@item
List of @code{KSP_TYPE}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html}.
@item
List of @code{SNES_TYPE}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESType.html}.
@end itemize

If either @code{PC_TYPE} or @code{KSP_TYPE} is set to @code{mumps} (and
PETSc is compiled with MUMPS support) then this direct solver is used.
For the mechanical problem, the default is to use GAMG as the
preconditioner and PETSc's default solver (GMRES). For the thermal
problem, the default is to use the default PETSc settings. For the modal
problem, the default is to use the default SLEPc settings. The
@code{GRADIENT} keyword controls how the derivatives (i.e.@ strains) at
the first-order nodes are to be computed out of the primary unknowns
(i.e.@ displacements).

@itemize
@item
@code{gauss} (default) computes the derivatives at the gauss points and
the extrapolates the values to the nodes
@item
@code{nodes} computes the derivatives direcetly at the nodes
@item
@code{none} does not compute any derivative at all
@end itemize

The way derivatives are computed at high-order nodes (i.e.@ those at the
middle of edges or faces) is controlled with @code{GRADIENT_HIGHER}:

@itemize
@item
@code{average} (default) assigns the plain average of the first-order
nodes that surrond each high-order node
@item
@code{none} computes the derivatives at the location of the high-order
nodes
@end itemize

The keyword @code{SMOOTH} controls how the gradient-based functions
(i.e.@ strains, stresses, etc) are smoothed---or not---to obtain nodal
values out of data which primarily comes from element-wise evaluations
at the Gauss points.

@itemize
@item
@code{always} (default) computes a single value for each node by
averaging the contributions of individual elements.
@item
@code{never} keeps the contribution of each individual element separate.
This option implies that the output mesh is different from the input
mesh as each element now has a ``copy'' of the original shared nodes.
@item
@code{material} averages element contribution only for those elements
that belong to the same material (i.e.@ physical group). As with
@code{never}, a new output mesh is created where the nodes are
duplicated even for those elements which belong to the same physical
group.
@end itemize

The way individual contributions of different elements to the same node
are averaged is controlled by @code{ELEMENT_WEIGHT}:

@itemize
@item
@code{volume_times_quality} (default) weights each element by the
product of its volume times its quality
@item
@code{volume} weights each element by the its volume
@item
@code{quality} weights each element by the its quality
@item
@code{flat} performs plain averages (i.e.@ the same weight for all
elements)
@end itemize

@node FINO_STEP
@subsection FINO_STEP
@anchor{#fino_step}
@quotation
Ask Fino to solve the problem and advance one step.
@end quotation

@verbatim
FINO_STEP [ JUST_BUILD | JUST_SOLVE ]
@end verbatim

The location of the @code{FINO_STEP} keyword within the input file marks
the logical location where the problem is solved and the result
functions (displacements, temperatures, stresses, etc.) are available
for output or further computation.

@node Mesh keywords
@section Mesh keywords
@anchor{#mesh-keywords}

@menu
* MATERIAL::
* MESH::
* MESH_FILL_VECTOR::
* MESH_FIND_MINMAX::
* MESH_INTEGRATE::
* MESH_MAIN::
* MESH_POST::
* PHYSICAL_GROUP::
* PHYSICAL_PROPERTY::
@end menu

@node MATERIAL
@subsection MATERIAL
@anchor{#material}
@quotation

@verbatim
MATERIAL <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1> [ PHYSICAL_GROUP <name_2> [ ... ] ] ] [ <property_name_1> <expr_1> [ <property_name_2> <expr_2> [ ... ] ] ]
@end verbatim

@end quotation

@node MESH
@subsection MESH
@anchor{#mesh}
@quotation
Reads an unstructured mesh from an external file in MSH, VTK or FRD
format.
@end quotation

@verbatim
MESH [ NAME <name> ] { FILE <file_id> | FILE_PATH <file_path> } [ DIMENSIONS <num_expr> ]
 [ SCALE <expr> ] [ OFFSET <expr_x> <expr_y> <expr_z> ]
 [ READ_SCALAR <name_in_mesh> AS <function_name> ] [...]
 [ READ_FUNCTION <function_name> ] [...]
@end verbatim

If there will be only one mesh in the input file, the @code{NAME} is
optional. Yet it might be needed in cases where there are many meshes
and one needs to refer to a particular mesh, such as in @code{MESH_POST}
or @code{MESH_INTEGRATE}. When solving PDEs (such as in Fino or
milonga), the first mesh is the problem mesh. Either a file identifier
(defined previously with a @code{FILE} keyword) or a file path should be
given. The format is read from the extension, which should be either

@itemize
@item
@code{.msh}
@uref{http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format,Gmsh ASCII
format}, versions 2.2, 4.0 or 4.1
@item
@code{.vtk}
@uref{https://lorensen.github.io/VTKExamples/site/VTKFileFormats/,ASCII
legacy VTK}
@item
@code{.frd}
@uref{https://web.mit.edu/calculix_v2.7/CalculiX/cgx_2.7/doc/cgx/node4.html,CalculiX's
FRD ASCII output})
@end itemize

Note than only MSH is suitable for defining PDE domains, as it is the
only one that provides information about physical groups. The spatial
dimensions should be given with @code{DIMENSION}. If material properties
are uniform and given with variables, the dimensions are not needed and
will be read from the file. But if spatial functions are needed (either
for properties or read from the mesh file), an explicit value for the
mesh dimensions is needed. If either @code{SCALE} or @code{OFFSET} are
given, the node position if first shifted and then scaled by the
provided amounts. For each @code{READ_SCALAR} keyword, a point-wise
defined function of space named @code{<function_name>} is defined and
filled with the scalar data named @code{<name_in_mesh>} contained in the
mesh file. The @code{READ_FUNCTION} keyword is a shortcut when the
scalar name and the to-be-defined function are the same. If no
@code{NAME} is given, the first mesh to be defined is called
@code{first}.

@node MESH_FILL_VECTOR
@subsection MESH_FILL_VECTOR
@anchor{#mesh_fill_vector}
@quotation
Fills the elements of a vector with data evaluated at the nodes or the
cells of a mesh.
@end quotation

@verbatim
MESH_FILL_VECTOR VECTOR <vector> { FUNCTION <function> | EXPRESSION <expr> } 
 [ MESH <name> ] [ NODES | CELLS ]
@end verbatim

The vector to be filled needs to be already defined and to have the
appropriate size, either the number of nodes or cells of the mesh
depending on @code{NODES} or @code{CELLS} (default is nodes). The
elements of the vectors will be either the @code{FUNCTION} or the
@code{EXPRESSION} of @math{x}, @math{y} and @math{z} evaluated at the
nodes or cells of the provided mesh. If there is more than one mesh, the
name has to be given.

@node MESH_FIND_MINMAX
@subsection MESH_FIND_MINMAX
@anchor{#mesh_find_minmax}
@quotation
Finds absolute extrema of a function or expression within a mesh-based
domain.
@end quotation

@verbatim
MESH_FIND_MINMAX { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <name> ] [ NODES | CELLS ]
 [ MIN <variable> ] [ I_MIN <variable> ] [ X_MIN <variable> ] [ Y_MIN <variable> ] [Z_MIN <variable> ]
 [ MAX <variable> ] [ I_MAX <variable> ] [ X_MAX <variable> ] [ Y_MAX <variable> ] [Z_MAX <variable> ]
@end verbatim

Either a @code{FUNCTION} or an @code{EXPRESSION} should be given. In the
first case, just the function name is expected (i.e.@ not its
arguments).

@node MESH_INTEGRATE
@subsection MESH_INTEGRATE
@anchor{#mesh_integrate}
@quotation
Performs a spatial integration of a function or expression over a mesh.
@end quotation

@verbatim
MESH_INTEGRATE { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <mesh_identifier> ] [ OVER <physical_group> ] [ NODES | CELLS ]
 RESULT <variable>
@end verbatim

The integrand may be either a @code{FUNCTION} or an @code{EXPRESSION}.
In the first case, just the function name is expected (i.e.@ not its
arguments). In the second case, a full algebraic expression including
the arguments is expected. If the expression is just @code{1} then the
volume (or area or length) of the domain is computed. Note that
arguments ought to be @code{x}, @code{y} and/or @code{z}. If there are
more than one mesh defined, an explicit one has to be given with
@code{MESH}. By default the integration is performed over the
highest-dimensional elements of the mesh. If the integration is to be
carried out over just a physical group, it has to be given in
@code{OVER}. Either @code{NODES} or @code{CELLS} define how the
integration is to be performed. In the first case a the integration is
performed using the Gauss points and weights associated to each element
type. In the second case, the integral is computed as the sum of the
product of the function evaluated at the center of each cell (element)
and the cell's volume. The scalar result of the integration is stored in
the variable given by @code{RESULT}. If the variable does not exist, it
is created. In the second case, a full algebraic expression including
the arguments is expected.

@node MESH_MAIN
@subsection MESH_MAIN
@anchor{#mesh_main}
@quotation

@verbatim
MESH_MAIN [ <name> ]
@end verbatim

@end quotation

@node MESH_POST
@subsection MESH_POST
@anchor{#mesh_post}
@quotation

@verbatim
MESH_POST [ MESH <mesh_identifier> ] { FILE <name> | FILE_PATH <file_path> } [ NO_MESH ] [ FORMAT { gmsh | vtk } ] [ CELLS | ] NODES ] [ NO_PHYSICAL_NAMES ] [ VECTOR <function1_x> <function1_y> <function1_z> ] [...] [ <scalar_function_1> ] [ <scalar_function_2> ] ...
@end verbatim

@end quotation

@node PHYSICAL_GROUP
@subsection PHYSICAL_GROUP
@anchor{#physical_group}
@quotation
Defines a physical group of elements within a mesh file.
@end quotation

@verbatim
PHYSICAL_GROUP <name> [ MESH <name> ] [ DIMENSION <expr> ]
 [ MATERIAL <name> ]
 [ BC <bc_1> <bc_2> ... ]
@end verbatim

A name is mandatory for each physical group defined within the input
file. If there is no physical group with the provided name in the mesh,
this instruction makes no effect. If there are many meshes, an explicit
mesh can be given with @code{MESH}. Otherwise, the physical group is
defined on the main mesh. An explicit dimension of the physical group
can be provided with @code{DIMENSION}. For volumetric elements, physical
groups can be linked to materials using @code{MATERIAL}. Note that if a
material is created with the same name as a physical group in the mesh,
they will be linked automatically. The @code{MATERIAL} keyword in
@code{PHYSICAL_GROUP} is used to link a physical group in a mesh file
and a material in the wasora input file with different names. For
non-volumetric elements, boundary conditions can be assigned by using
the @code{BC} keyword. This should be the last keyword of the line, and
any token afterwards is treated specially by the underlying solver
(i.e.@ Fino or milonga).

@node PHYSICAL_PROPERTY
@subsection PHYSICAL_PROPERTY
@anchor{#physical_property}
@quotation

@verbatim
PHYSICAL_PROPERTY <name> [ <material_name1> <expr1> [ <material_name2> <expr2> ] ... ]
@end verbatim

@end quotation

@node Special input distributions
@section Special input distributions
@anchor{#special-input-distributions}
TBD.

@node Boundary conditions
@section Boundary conditions
@anchor{#boundary-conditions}

@node Boundary conditions
@section Boundary conditions
@anchor{#boundary-conditions-1}
TBD.

@node Result functions
@section Result functions
@anchor{#result-functions}
TBD.

@node Wasora keywords
@section Wasora keywords
@anchor{#wasora-keywords}

@menu
* =::
* =::
* ABORT::
* ALIAS::
* CALL::
* CLOSE::
* CONST::
* DEFAULT_ARGUMENT_VALUE::
* DIFFERENTIAL::
* DO_NOT_EVALUATE_AT_PARSE_TIME::
* FILE::
* FIT::
* FUNCTION::
* HISTORY::
* IF::
* IMPLICIT::
* INCLUDE::
* INITIAL_CONDITIONS_MODE::
* LOAD_PLUGIN::
* LOAD_ROUTINE::
* M4::
* MATRIX::
* MINIMIZE::
* PARAMETRIC::
* PHASE_SPACE::
* PRINT::
* PRINT_FUNCTION::
* PRINT_VECTOR::
* READ::
* SEMAPHORE::
* SHELL::
* SOLVE::
* TIME_PATH::
* VAR::
* VECTOR::
* VECTOR_SORT::
* WRITE::
@end menu

@node =
@subsection .=
@anchor{#section}
@quotation
Add an equation to the DAE system to be solved in the phase space
spanned by @code{PHASE_SPACE}.
@end quotation

@verbatim
{ 0[(i[,j]][<imin:imax[;jmin:jmax]>] | <expr1> } .= <expr2>
@end verbatim

@node =
@subsection =
@anchor{#section-1}
@quotation
Assign an expression to a variable, a vector or a matrix.
@end quotation

@verbatim
<var>[ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <vector>(<expr_i>)[<expr_i_min, expr_i_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <matrix>(<expr_i>,<expr_j>)[<expr_i_min, expr_i_max; expr_j_min, expr_j_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr>
@end verbatim

@node ABORT
@subsection ABORT
@anchor{#abort}
@quotation
Catastrophically abort the execution and quit wasora.
@end quotation

@verbatim
ABORT
@end verbatim

Whenever the instruction @code{ABORT} is executed, wasora quits without
closing files or unlocking shared memory objects. The objective of this
instruction is, as illustrated in the examples, either to debug complex
input files and check the values of certain variables or to
conditionally abort the execution using @code{IF} clauses.

@node ALIAS
@subsection ALIAS
@anchor{#alias}
@quotation
Define a scalar alias of an already-defined indentifier.
@end quotation

@verbatim
ALIAS { <new_var_name> IS <existing_object> | <existing_object> AS <new_name> }
@end verbatim

The existing object can be a variable, a vector element or a matrix
element. In the first case, the name of the variable should be given as
the existing object. In the second case, to alias the second element of
vector @code{v} to the new name @code{new}, @code{v(2)} should be given
as the existing object. In the third case, to alias second element (2,3)
of matrix @code{M} to the new name @code{new}, @code{M(2,3)} should be
given as the existing object.

@node CALL
@subsection CALL
@anchor{#call}
@quotation
Call a previously dynamically-loaded user-provided routine.
@end quotation

@verbatim
CALL <name> [ expr_1 expr_2 ... expr_n ]
@end verbatim

@node CLOSE
@subsection CLOSE
@anchor{#close}
@quotation
Explicitly close an already-@code{OPEN}ed file.
@end quotation

@verbatim
CLOSE
@end verbatim

@node CONST
@subsection CONST
@anchor{#const}
@quotation
Mark a scalar variable, vector or matrix as a constant.
@end quotation

@verbatim
CONST name_1 [ <name_2> ] ... [ <name_n> ]
@end verbatim

@node DEFAULT_ARGUMENT_VALUE
@subsection DEFAULT_ARGUMENT_VALUE
@anchor{#default_argument_value}
@quotation
Give a default value for an optional commandline argument.
@end quotation

@verbatim
DEFAULT_ARGUMENT_VALUE <constant> <string>
@end verbatim

If a @code{$n} construction is found in the input file but the
commandline argument was not given, the default behavior is to fail
complaining that an extra argument has to be given in the commandline.
With this keyword, a default value can be assigned if no argument is
given, thus avoiding the failure and making the argument optional.

@node DIFFERENTIAL
@subsection DIFFERENTIAL
@anchor{#differential}
@quotation
Explicitly mark variables, vectors or matrices as ``differential'' to
compute intial conditions of DAE systems.
@end quotation

@verbatim
DIFFERENTIAL { <var_1> <var_2> ... | <vector_1> <vector_2> ... | <matrix_1> <matrix_2> ... }
@end verbatim

@node DO_NOT_EVALUATE_AT_PARSE_TIME
@subsection DO_NOT_EVALUATE_AT_PARSE_TIME
@anchor{#do_not_evaluate_at_parse_time}
@quotation
Ask wasora not to evaluate assignments at parse time.
@end quotation

@verbatim
DO_NOT_EVALUATE_AT_PARSE_TIME
@end verbatim

@node FILE
@subsection FILE
@anchor{#file}
@quotation
Define a file, either as input or as output, for further usage.
@end quotation

@verbatim
< FILE | OUTPUT_FILE | INPUT_FILE > <name> <printf_format> [ expr_1 expr_2 ... expr_n ] [ INPUT | OUTPUT | MODE <fopen_mode> ] [ OPEN | DO_NOT_OPEN ]
@end verbatim

@node FIT
@subsection FIT
@anchor{#fit}
@quotation
Fit a function of one or more arguments to a set of data.
@end quotation

@verbatim
FIT <function_to_be_fitted> TO <function_with_data> VIA <var_1> <var_2> ... <var_n> [ GRADIENT <expr_1> <expr_2> ... <expr_n> ] [ RANGE_MIN <expr_1> <expr_2> ... <expr_n> ] [ RANGE_MAX <expr_1> <expr_2> ... <expr_n> ] [ DELTAEPSREL <expr> ] [ DELTAEPSABS <expr> ] [ MAX_ITER <expr> ] [ VERBOSE ] [ RERUN | DO_NOT_RERUN ]
@end verbatim

The function with the data has to be point-wise defined. The function to
be fitted hast to be parametrized with at least one of the variables
provided after the @code{VIA} keyword. Only the names of the functions
have to be given. Both functions have to have the same number of
arguments. The initial guess of the solution is given by the initial
value of the variables listed in the @code{VIA} keyword. Analytical
expressions for the gradient of the function to be fitted with respect
to the parameters to be fitted can be optionally given with the
@code{GRADIENT} keyword. If none is provided, the gradient will be
computed numerically using finite differences. A range over which the
residuals are to be minimized can be given with @code{RANGE_MIN} and
@code{RANGE_MAX}. For multidimensional fits, the range is an hypercube.
If no range is given, all the definition points of the function witht
the data are used for the fit. Convergence can be controlled by given
the relative and absolute tolreances with @code{DELTAEPSREL} (default
1e-4) and @code{DELTAEPSABS} (default 1e-6), and with the maximum number
of iterations @code{MAX_ITER} (default 100). If the optional keyword
@code{VERBOSE} is given, some data of the intermediate steps is written
in the standard output.

@node FUNCTION
@subsection FUNCTION
@anchor{#function}
@quotation
Define a function of one or more variables.
@end quotation

@verbatim
FUNCTION <name>(<var_1>[,var2,...,var_n]) { [ = <expr> | FILE_PATH <file_path> | ROUTINE <name> | | MESH <name> { DATA <new_vector_name> | VECTOR <existing_vector_name> } { NODES | CELLS } | [ VECTOR_DATA <vector_1> <vector_2> ... <vector_n> <vector_n+1> ] } [COLUMNS <expr_1> <expr_2> ... <expr_n> <expr_n+1> ] [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen | nearest | shepard | shepard_kd | bilinear } ] [ INTERPOLATION_THRESHOLD <expr> ] [ SHEPARD_RADIUS <expr> ] [ SHEPARD_EXPONENT <expr> ] [ SIZES <expr_1> <expr_2> ... <expr_n> ] [ X_INCREASES_FIRST <expr> ] [ DATA <num_1> <num_2> ... <num_N> ]
@end verbatim

The number of variables @math{n} is given by the number of arguments
given between parenthesis after the function name. The arguments are
defined as new variables if they had not been already defined as
variables. If the function is given as an algebraic expression, the
short-hand operator @code{:=} can be used. That is to say,
@code{FUNCTION f(x) = x^2} is equivalent to @code{f(x) := x^2}. If a
@code{FILE_PATH} is given, an ASCII file containing at least @math{n+1}
columns is expected. By default, the first @math{n} columns are the
values of the arguments and the last column is the value of the function
at those points. The order of the columns can be changed with the
keyword @code{COLUMNS}, which expects @math{n+1} expressions
corresponding to the column numbers. A function of type @code{ROUTINE}
calls an already-defined user-provided routine using the @code{CALL}
keyword and passes the values of the variables in each required
evaluation as a @code{double *} argument. If @code{MESH} is given, the
definition points are the nodes or the cells of the mesh. The function
arguments should be @math{(x)}, @math{(x,y)} or @math{(x,y,z)} matching
the dimension the mesh. If the keyword @code{DATA} is used, a new empty
vector of the appropriate size is defined. The elements of this new
vector can be assigned to the values of the function at the @math{i}-th
node or cell. If the keyword @code{VECTOR} is used, the values of the
dependent variable are taken to be the values of the already-existing
vector. Note that this vector should have the size of the number of
nodes or cells the mesh has, depending on whether @code{NODES} or
@code{CELLS} is given. If @code{VECTOR_DATA} is given, a set of
@math{n+1} vectors of the same size is expected. The first @math{n+1}
correspond to the arguments and the last one is the function value.
Interpolation schemes can be given for either one or multi-dimensional
functions with @code{INTERPOLATION}. Available schemes for @math{n=1}
are:

@itemize
@item
linear
@item
polynomial, the grade is equal to the number of data minus one
@item
spline, cubic (needs at least 3 points)
@item
spline_periodic
@item
akima (needs at least 5 points)
@item
akima_periodic (needs at least 5 points)
@item
steffen, always-monotonic splines-like (available only with GSL >= 2.0)
@end itemize

Default interpolation scheme for one-dimensional functions is
@code{(*gsl_interp_linear)}.

Available schemes for @math{n>1} are:

@itemize
@item
nearest, @math{f(\vec{x})} is equal to the value of the closest
definition point
@item
shepard,
@uref{https://en.wikipedia.org/wiki/Inverse_distance_weighting,inverse
distance weighted average definition points} (might lead to inefficient
evaluation)
@item
shepard_kd,
@uref{https://en.wikipedia.org/wiki/Inverse_distance_weighting#Modified_Shepard's_method,average
of definition points within a kd-tree} (more efficient evaluation
provided @code{SHEPARD_RADIUS} is set to a proper value)
@item
bilinear, only available if the definition points configure an
structured hypercube-like grid. If @math{n>3}, @code{SIZES} should be
given.
@end itemize

For @math{n>1}, if the euclidean distance between the arguments and the
definition points is smaller than @code{INTERPOLATION_THRESHOLD}, the
definition point is returned and no interpolation is performed. Default
value is square root of @code{9.5367431640625e-07}. The initial radius
of points to take into account in @code{shepard_kd} is given by
@code{SHEPARD_RADIUS}. If no points are found, the radius is double
until at least one definition point is found. The radius is doubled
until at least one point is found. Default is @code{1.0}. The exponent
of the @code{shepard} method is given by @code{SHEPARD_EXPONENT}.
Default is @code{2}. When requesting @code{bilinear} interpolation for
@math{n>3}, the number of definition points for each argument variable
has to be given with @code{SIZES}, and wether the definition data is
sorted with the first argument changing first (@code{X_INCREASES_FIRST}
evaluating to non-zero) or with the last argument changing first (zero).
The function can be pointwise-defined inline in the input using
@code{DATA}. This should be the last keyword of the line, followed by
@math{N=k\cdot (n+1)} expresions giving @math{k} definition points:
@math{n} arguments and the value of the function. Multiline continuation
using brackets @code{@{} and @code{@}} can be used for a clean data
organization. See the examples.

@node HISTORY
@subsection HISTORY
@anchor{#history}
@quotation
Record the time history of a variable as a function of time.
@end quotation

@verbatim
HISTORY <variable> <function>
@end verbatim

@node IF
@subsection IF
@anchor{#if}
@quotation
Begin a conditional block.
@end quotation

@verbatim
IF expr
<block_of_instructions_if_expr_is_true>
[ ELSE ]
[block_of_instructions_if_expr_is_false]
ENDIF
@end verbatim

@node IMPLICIT
@subsection IMPLICIT
@anchor{#implicit}
@quotation
Define whether implicit declaration of variables is allowed or not.
@end quotation

@verbatim
IMPLICIT { NONE | ALLOWED }
@end verbatim

By default, wasora allows variables (but not vectors nor matrices) to be
implicitly declared. To avoid introducing errors due to typos, explicit
declaration of variables can be forced by giving @code{IMPLICIT NONE}.
Whether implicit declaration is allowed or explicit declaration is
required depends on the last @code{IMPLICIT} keyword given, which by
default is @code{ALLOWED}.

@node INCLUDE
@subsection INCLUDE
@anchor{#include}
@quotation
Include another wasora input file.
@end quotation

@verbatim
INCLUDE <file_path> [ FROM <num_expr> ] [ TO <num_expr> ]
@end verbatim

Includes the input file located in the string @code{file_path} at the
current location. The effect is the same as copying and pasting the
contents of the included file at the location of the @code{INCLUDE}
keyword. The path can be relative or absolute. Note, however, that when
including files inside @code{IF} blocks that instructions are
conditionally-executed but all definitions (such as function
definitions) are processed at parse-time independently from the
evaluation of the conditional. The optional @code{FROM} and @code{TO}
keywords can be used to include only portions of a file.

@node INITIAL_CONDITIONS_MODE
@subsection INITIAL_CONDITIONS_MODE
@anchor{#initial_conditions_mode}
@quotation
Define how initial conditions of DAE problems are computed.
@end quotation

@verbatim
INITIAL_CONDITIONS_MODE { AS_PROVIDED | FROM_VARIABLES | FROM_DERIVATIVES }
@end verbatim

In DAE problems, initial conditions may be either:

@itemize
@item
equal to the provided expressions (@code{AS_PROVIDED})
@item
the derivatives computed from the provided phase-space variables
(@code{FROM_VARIABLES})
@item
the phase-space variables computed from the provided derivatives
(@code{FROM_DERIVATIVES})
@end itemize

In the first case, it is up to the user to fulfill the DAE system
at@ @math{t = 0}. If the residuals are not small enough, a convergence
error will occur. The @code{FROM_VARIABLES} option means calling IDA's
@code{IDACalcIC} routine with the parameter @code{IDA_YA_YDP_INIT}. The
@code{FROM_DERIVATIVES} option means calling IDA's @code{IDACalcIC}
routine with the parameter IDA_Y_INIT. Wasora should be able to
automatically detect which variables in phase-space are differential and
which are purely algebraic. However, the @code{DIFFERENTIAL} keyword may
be used to explicitly define them. See the (SUNDIALS
documentation)[https://computation.llnl.gov/casc/sundials/documentation/ida_guide.pdf]
for further information.

@node LOAD_PLUGIN
@subsection LOAD_PLUGIN
@anchor{#load_plugin}
@quotation
Load a wasora plug-in from a dynamic shared object.
@end quotation

@verbatim
LOAD_PLUGIN { <file_path> | <plugin_name> }
@end verbatim

A wasora plugin in the form of a dynamic shared object
(i.e.@ @code{.so}) can be loaded either with the @code{LOAD_PLUGIN}
keyword or from the command line with the @code{-p} option. Either a
file path or a plugin name can be given. The following locations are
tried:

@itemize
@item
the current directory @code{./}
@item
the parent directory @code{../}
@item
the user's @code{LD_LIBRARY_PATH}
@item
the cache file @code{/etc/ld.so.cache}
@item
the directories @code{/lib}, @code{/usr/lib}, @code{/usr/local/lib}
@end itemize

If a wasora plugin was compiled and installed following the
@code{make install} procedure, the plugin should be loaded by just
passing the name to @code{LOAD_PLUGIN}.

@node LOAD_ROUTINE
@subsection LOAD_ROUTINE
@anchor{#load_routine}
@quotation
Load one or more routines from a dynamic shared object.
@end quotation

@verbatim
LOAD_ROUTINE <file_path> <routine_1> [ <routine_2> ... <routine_n> ]
@end verbatim

@node M4
@subsection M4
@anchor{#m4}
@quotation
Call the @code{m4} macro processor with definitions from wasora
variables or expressions.
@end quotation

@verbatim
M4 { INPUT_FILE <file_id> | FILE_PATH <file_path> } { OUTPUT_FILE <file_id> | OUTPUT_FILE_PATH <file_path> } [ EXPAND <name> ] ... } [ MACRO <name> [ <format> ] <definition> ] ... }
@end verbatim

@node MATRIX
@subsection MATRIX
@anchor{#matrix}
@quotation
Define a matrix.
@end quotation

@verbatim
MATRIX <name> ROWS <expr> COLS <expr> [ DATA num_expr_1 num_expr_2 ... num_expr_n ]
@end verbatim

@node MINIMIZE
@subsection MINIMIZE
@anchor{#minimize}
@quotation
Find the combination of arguments that give a (relative) minimum of a
function, i.e.@ run an optimization problem.
@end quotation

@verbatim
MINIMIZE <function> <function> [ METHOD { conjugate_fr | conjugate_pr | vector_bfgs2 | vector_bfgs | steepest_descent | nmsimplex2 | nmsimplex | nmsimplex2rand } [ GRADIENT <expr_1> <expr_2> ... <expr_n> ] [ GUESS <expr_1> <expr_2> ... <expr_n> ] [ MIN <expr_1> <expr_2> ... <expr_n> ] [ MAX <expr_1> <expr_2> ... <expr_n> ] [ STEP <expr_1> <expr_2> ... <expr_n> ] [ VERBOSE ] [ NORERUN ] [ MAX_ITER <expr> ] [ TOL <expr> ] [ GRADTOL <expr> ]
@end verbatim

@node PARAMETRIC
@subsection PARAMETRIC
@anchor{#parametric}
@quotation
Systematically sweep a zone of the parameter space, i.e.@ perform a
parametric run.
@end quotation

@verbatim
PARAMETRIC <var_1> [ ... <var_n> ] [ TYPE { linear | logarithmic | random | gaussianrandom | sobol | niederreiter | halton | reversehalton } ] [ MIN <num_expr_1> ... <num_expr_n> ] [ MAX <num_expr_1> ... <num_expr_n> ] [ STEP <num_expr_1> ... <num_expr_n> ] [ NSTEPS <num_expr_1> ... <num_expr_n> ] [ OUTER_STEPS <num_expr> ] [ MAX_DAUGHTERS <num_expr> ] [ OFFSET <num_expr> ] [ ADIABATIC ]
@end verbatim

@node PHASE_SPACE
@subsection PHASE_SPACE
@anchor{#phase_space}
@quotation
Define which variables, vectors and/or matrices belong to the phase
space of the DAE system to be solved.
@end quotation

@verbatim
PHASE_SPACE { <vars> | <vectors> | <matrices> }
@end verbatim

@node PRINT
@subsection PRINT
@anchor{#print}
@quotation
Print plain-text and/or formatted data to the standard output or into an
output file.
@end quotation

@verbatim
PRINT [ FILE <file_id> | FILE_PATH <file_path> ] [ NONEWLINE ] [ SEP <string> ] [ NOSEP ] [ HEADER ] [ SKIP_STEP <expr> ] [ SKIP_STATIC_STEP <expr> ] [ SKIP_TIME <expr> ] [ SKIP_HEADER_STEP <expr> ] [ <object_1> <object_2> ... <object_n> ] [ TEXT <string_1> ... TEXT <string_n> ]
@end verbatim

Each argument @code{object} that is not a keyword is expected to be part
of the output, can be either a matrix, a vector, an scalar algebraic
expression. If the given object cannot be solved into a valid matrix,
vector or expression, it is treated as a string literal if
@code{IMPLICIT} is @code{ALLOWED}, otherwise a parser error is raised.
To explicitly interpret an object as a literal string even if it
resolves to a valid numerical expression, it should be prefixed with the
@code{TEXT} keyword. Hashes @code{#} appearing literal in text strings
have to be quoted to prevent the parser to treat them as comments within
the wasora input file and thus ignoring the rest of the line. Whenever
an argument starts with a porcentage sign @code{%}, it is treated as a C
@code{printf}-compatible format definition and all the objects that
follow it are printed using the given format until a new format
definition is found. The objects are treated as double-precision
floating point numbers, so only floating point formats should be given.
The default format is @code{"%g"}. Matrices, vectors, scalar
expressions, format modifiers and string literals can be given in any
desired order, and are processed from left to right. Vectors are printed
element-by-element in a single row. See @code{PRINT_VECTOR} to print
vectors column-wise. Matrices are printed element-by-element in a single
line using row-major ordering if mixed with other objects but in the
natural row and column fashion if it is the only given object. If the
@code{FILE} keyword is not provided, default is to write to stdout. If
the @code{NONEWLINE} keyword is not provided, default is to write a
newline @code{\n} character after all the objects are processed. The
@code{SEP} keywords expects a string used to separate printed objects,
the default is a tab `DEFAULT_PRINT_SEPARATOR' character. Use the
@code{NOSEP} keyword to define an empty string as object separator. If
the @code{HEADER} keyword is given, a single line containing the literal
text given for each object is printed at the very first time the
@code{PRINT} instruction is processed, starting with a hash @code{#}
character. If the @code{SKIP_STEP} (@code{SKIP_STATIC_STEP})keyword is
given, the instruction is processed only every the number of transient
(static) steps that results in evaluating the expression, which may not
be constant. By default the @code{PRINT} instruction is evaluated every
step. The @code{SKIP_HEADER_STEP} keyword works similarly for the
optional @code{HEADER} but by default it is only printed once. The
@code{SKIP_TIME} keyword use time advancements to choose how to skip
printing and may be useful for non-constant time-step problems.

@node PRINT_FUNCTION
@subsection PRINT_FUNCTION
@anchor{#print_function}
@quotation
Print one or more functions as a table of values of dependent and
independent variables.
@end quotation

@verbatim
PRINT_FUNCTION <function_1> [ { function_2 | expr_1 } ... { function_n | expr_n-1 } ] [ FILE <file_id> | FILE_PATH <file_path> ] [ HEADER ] [ MIN <expr_1> <expr_2> ... <expr_m> ] [ MAX <expr_1> <expr_2> ... <expr_m> ] [ STEP <expr_1> <expr_2> ... <expr_m> ] [ NSTEPs <expr_1> <expr_2> ... <expr_m> ] [ FORMAT <print_format> ] [ PHYSICAL_ENTITY <name> ]
@end verbatim

@node PRINT_VECTOR
@subsection PRINT_VECTOR
@anchor{#print_vector}
@quotation
Print the elements of one or more vectors.
@end quotation

@verbatim
PRINT_VECTOR [ FILE <file_id> ] FILE_PATH <file_path> ] [ { VERTICAL | HORIZONTAL } ] [ ELEMS_PER_LINE <expr> ] [ FORMAT <print_format> ] <vector_1> [ vector_2 ... vector_n ]
@end verbatim

@node READ
@subsection READ
@anchor{#read}
@quotation
Read data (variables, vectors o matrices) from files or shared-memory
segments.
@end quotation

@verbatim
[ READ | WRITE ] [ SHM <name> ] [ { ASCII_FILE_PATH | BINARY_FILE_PATH } <file_path> ] [ { ASCII_FILE | BINARY_FILE } <identifier> ] [ IGNORE_NULL ] [ object_1 object_2 ... object_n ]
@end verbatim

@node SEMAPHORE
@subsection SEMAPHORE
@anchor{#semaphore}
@quotation
Perform either a wait or a post operation on a named shared semaphore.
@end quotation

@verbatim
[ SEMAPHORE | SEM ] <name> { WAIT | POST }
@end verbatim

@node SHELL
@subsection SHELL
@anchor{#shell}
@quotation
Execute a shell command.
@end quotation

@verbatim
SHELL <print_format> [ expr_1 expr_2 ... expr_n ]
@end verbatim

@node SOLVE
@subsection SOLVE
@anchor{#solve}
@quotation
Solve a non-linear system of@ @math{n} equations with@ @math{n}
unknowns.
@end quotation

@verbatim
SOLVE <n> UNKNOWNS <var_1> <var_2> ... <var_n> RESIDUALS <expr_1> <expr_2> ... <expr_n> ] GUESS <expr_1> <expr_2> ... <expr_n> ] [ METHOD { dnewton | hybrid | hybrids | broyden } ] [ EPSABS <expr> ] [ EPSREL <expr> ] [ MAX_ITER <expr> ] [ VERBOSE ]
@end verbatim

@node TIME_PATH
@subsection TIME_PATH
@anchor{#time_path}
@quotation
Force transient problems to pass through specific instants of time.
@end quotation

@verbatim
TIME_PATH <expr_1> [ <expr_2> [ ... <expr_n> ] ]
@end verbatim

The time step @code{dt} will be reduced whenever the distance between
the current time @code{t} and the next expression in the list is greater
than @code{dt} so as to force @code{t} to coincide with the expressions
given. The list of expresssions should evaluate to a sorted list of
values.

@node VAR
@subsection VAR
@anchor{#var}
@quotation
Define one or more scalar variables.
@end quotation

@verbatim
VAR <name_1> [ <name_2> ] ... [ <name_n> ]
@end verbatim

@node VECTOR
@subsection VECTOR
@anchor{#vector}
@quotation
Define a vector.
@end quotation

@verbatim
VECTOR <name> SIZE <expr> [ DATA <expr_1> <expr_2> ... <expr_n> | FUNCTION_DATA <function> ]
@end verbatim

@node VECTOR_SORT
@subsection VECTOR_SORT
@anchor{#vector_sort}
@quotation
Sort the elements of a vector using a specific numerical order,
potentially making the same rearrangement of another vector.
@end quotation

@verbatim
VECTOR_SORT <vector> [ ASCENDING_ORDER | DESCENDING_ORDER ] [ <vector> ]
@end verbatim

@node WRITE
@subsection WRITE
@anchor{#write}
@quotation
Write data (variables, vectors o matrices) to files or shared-memory
segments. See the @code{READ} keyword for usage details.
@end quotation

@node Fino variables
@section Fino variables
@anchor{#fino-variables}

@menu
* delta_sigma_max::
* displ_max::
* displ_max_x::
* displ_max_y::
* displ_max_z::
* fino_abstol::
* fino_divtol::
* fino_gamg_threshold::
* fino_iterations::
* fino_max_iterations::
* fino_penalty_weight::
* fino_reltol::
* fino_residual_norm::
* lambda::
* memory::
* memory_available::
* memory_petsc::
* nodes_rough::
* petsc_flops::
* sigma_max::
* sigma_max_x::
* sigma_max_y::
* sigma_max_z::
* strain_energy::
* time_cpu_build::
* time_cpu_solve::
* time_cpu_stress::
* time_petsc_build::
* time_petsc_solve::
* time_petsc_stress::
* time_wall_build::
* time_wall_solve::
* time_wall_stress::
* time_wall_total::
* T_max::
* T_min::
* u_at_displ_max::
* u_at_sigma_max::
* v_at_displ_max::
* v_at_sigma_max::
* w_at_displ_max::
* w_at_sigma_max::
@end menu

@node delta_sigma_max
@subsection delta_sigma_max
@anchor{#delta_sigma_max}
@quotation
@end quotation
The uncertainty of the maximum Von@ Mises stress@ @math{\sigma} of the
elastic problem. Not to be confused with the maximum uncertainty of the
Von@ Mises stress.

@node displ_max
@subsection displ_max
@anchor{#displ_max}
@quotation
@end quotation
The module of the maximum displacement of the elastic problem.

@node displ_max_x
@subsection displ_max_x
@anchor{#displ_max_x}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum displacement of the elastic
problem.

@node displ_max_y
@subsection displ_max_y
@anchor{#displ_max_y}
@quotation
@end quotation
The@ @math{y} coordinate of the maximum displacement of the elastic
problem.

@node displ_max_z
@subsection displ_max_z
@anchor{#displ_max_z}
@quotation
@end quotation
The@ @math{z} coordinate of the maximum displacement of the elastic
problem.

@node fino_abstol
@subsection fino_abstol
@anchor{#fino_abstol}
@quotation
@end quotation
Absolute tolerance of the linear solver, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{1e-50}.

@node fino_divtol
@subsection fino_divtol
@anchor{#fino_divtol}
@quotation
@end quotation
Divergence tolerance, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{1e+4}.

@node fino_gamg_threshold
@subsection fino_gamg_threshold
@anchor{#fino_gamg_threshold}
@quotation
@end quotation
Relative threshold to use for dropping edges in aggregation graph for
the [Geometric Algebraic Multigrid Preconditioner](http: as passed to
PETSc's [@code{PCGAMGSetThreshold}](http: A value of 0.0 means keep all
nonzero entries in the graph; negative means keep even zero entries in
the graph. Default @code{0.01}.

@node fino_iterations
@subsection fino_iterations
@anchor{#fino_iterations}
@quotation
@end quotation
This variable contains the actual number of iterations used by the
solver. It is set after @code{FINO_STEP}.

@node fino_max_iterations
@subsection fino_max_iterations
@anchor{#fino_max_iterations}
@quotation
@end quotation
Number of maximum iterations before diverging, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{10000}.

@node fino_penalty_weight
@subsection fino_penalty_weight
@anchor{#fino_penalty_weight}
@quotation
@end quotation
The weight @math{w} used when setting multi-freedom boundary conditions.
Higher values mean better precision in the constrain but distort the
matrix condition number. Default is @code{1e8}.

@node fino_reltol
@subsection fino_reltol
@anchor{#fino_reltol}
@quotation
@end quotation
Relative tolerance of the linear solver, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{1e-6}.

@node fino_residual_norm
@subsection fino_residual_norm
@anchor{#fino_residual_norm}
@quotation
@end quotation
This variable contains the residual obtained by the solver. It is set
after @code{FINO_STEP}.

@node lambda
@subsection lambda
@anchor{#lambda}
@quotation
@end quotation
Requested eigenvalue. It is equal to 1.0 until @code{FINO_STEP} is
executed.

@node memory
@subsection memory
@anchor{#memory}
@quotation
@end quotation
Maximum resident set size (global memory used), in bytes.

@node memory_available
@subsection memory_available
@anchor{#memory_available}
@quotation
@end quotation
Total available memory, in bytes.

@node memory_petsc
@subsection memory_petsc
@anchor{#memory_petsc}
@quotation
@end quotation
Maximum resident set size (memory used by PETSc), in bytes.

@node nodes_rough
@subsection nodes_rough
@anchor{#nodes_rough}
@quotation
@end quotation
The number of nodes of the mesh in @code{ROUGH} mode.

@node petsc_flops
@subsection petsc_flops
@anchor{#petsc_flops}
@quotation
@end quotation
Number of floating point operations performed by PETSc/SLEPc.

@node sigma_max
@subsection sigma_max
@anchor{#sigma_max}
@quotation
@end quotation
The maximum von Mises stress@ @math{\sigma} of the elastic problem.

@node sigma_max_x
@subsection sigma_max_x
@anchor{#sigma_max_x}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum von Mises stress@ @math{\sigma}
of the elastic problem.

@node sigma_max_y
@subsection sigma_max_y
@anchor{#sigma_max_y}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum von Mises stress@ @math{\sigma}
of the elastic problem.

@node sigma_max_z
@subsection sigma_max_z
@anchor{#sigma_max_z}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum von Mises stress@ @math{\sigma}
of the elastic problem.

@node strain_energy
@subsection strain_energy
@anchor{#strain_energy}
@quotation
@end quotation
The strain energy stored in the solid, computed as
@math{1/2 \cdot \vec{u}^T K \vec{u}} where @math{\vec{u}} is the
displacements vector and @math{K} is the stiffness matrix.

@node time_cpu_build
@subsection time_cpu_build
@anchor{#time_cpu_build}
@quotation
@end quotation
CPU time insumed to build the problem matrices, in seconds.

@node time_cpu_solve
@subsection time_cpu_solve
@anchor{#time_cpu_solve}
@quotation
@end quotation
CPU time insumed to solve the problem, in seconds.

@node time_cpu_stress
@subsection time_cpu_stress
@anchor{#time_cpu_stress}
@quotation
@end quotation
CPU time insumed to compute the stresses from the displacements, in
seconds.

@node time_petsc_build
@subsection time_petsc_build
@anchor{#time_petsc_build}
@quotation
@end quotation
CPU time insumed by PETSc to build the problem matrices, in seconds.

@node time_petsc_solve
@subsection time_petsc_solve
@anchor{#time_petsc_solve}
@quotation
@end quotation
CPU time insumed by PETSc to solve the eigen-problem, in seconds.

@node time_petsc_stress
@subsection time_petsc_stress
@anchor{#time_petsc_stress}
@quotation
@end quotation
CPU time insumed by PETSc to compute the stresses, in seconds.

@node time_wall_build
@subsection time_wall_build
@anchor{#time_wall_build}
@quotation
@end quotation
Wall time insumed to build the problem matrices, in seconds.

@node time_wall_solve
@subsection time_wall_solve
@anchor{#time_wall_solve}
@quotation
@end quotation
Wall time insumed to solve the problem, in seconds.

@node time_wall_stress
@subsection time_wall_stress
@anchor{#time_wall_stress}
@quotation
@end quotation
Wall time insumed to compute the stresses, in seconds.

@node time_wall_total
@subsection time_wall_total
@anchor{#time_wall_total}
@quotation
@end quotation
Wall time insumed to initialize, build and solve, in seconds. CPU time
insumed to initialize, build and solve, in seconds. CPU time insumed by
PETSc to initialize, build and solve, in seconds.

@node T_max
@subsection T_max
@anchor{#t_max}
@quotation
@end quotation
The maximum temperature@ @math{T_\r{max}} of the thermal problem.

@node T_min
@subsection T_min
@anchor{#t_min}
@quotation
@end quotation
The minimum temperature@ @math{T_\r{min}} of the thermal problem.

@node u_at_displ_max
@subsection u_at_displ_max
@anchor{#u_at_displ_max}
@quotation
@end quotation
The@ @math{x} component@ @math{u} of the maximum displacement of the
elastic problem.

@node u_at_sigma_max
@subsection u_at_sigma_max
@anchor{#u_at_sigma_max}
@quotation
@end quotation
The@ @math{x} component@ @math{u} of the displacement where the maximum
von Mises stress@ @math{\sigma} of the elastic problem is located.

@node v_at_displ_max
@subsection v_at_displ_max
@anchor{#v_at_displ_max}
@quotation
@end quotation
The@ @math{y} component@ @math{v} of the maximum displacement of the
elastic problem.

@node v_at_sigma_max
@subsection v_at_sigma_max
@anchor{#v_at_sigma_max}
@quotation
@end quotation
The@ @math{y} component@ @math{v} of the displacement where the maximum
von Mises stress@ @math{\sigma} of the elastic problem is located.

@node w_at_displ_max
@subsection w_at_displ_max
@anchor{#w_at_displ_max}
@quotation
@end quotation
The@ @math{z} component@ @math{w} of the maximum displacement of the
elastic problem.

@node w_at_sigma_max
@subsection w_at_sigma_max
@anchor{#w_at_sigma_max}
@quotation
@end quotation
The@ @math{z} component@ @math{w} of the displacement where the maximum
von Mises stress@ @math{\sigma} of the elastic problem is located.

@bye
